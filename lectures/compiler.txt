class: 'class' className '{' classVarDec* subroutineDec* '}'
className: identifier
subroutineName: identifier
varName: identifier
subroutineDec:
  ('constructor' | 'function' | 'method')
  ('void' | type) subroutineName
  '(' parameterList ')' subroutineBody
subroutineBody: '{' varDec* statements '}'
varDec: 'var' type varName (',' varName)* ';'
statements: statement*
statement:
  letStatement | ifStatement | whileStatement |
  doStatement | returnStatement
letStatement:
  'let' varName ('[' expression ']')? '=' expression ';'

expression: term (op term)*
op: '+' | '-' | '*' | ...
unaryOp: '-' | '~'
term: integerConstant | stringConstant
  | keywordConstant | varName
  | '(' expression ')'
  | unaryOp term
  | subroutineCall
  | varName '[' expression ']'
keywordConstant: 'true' | 'false' | 'null' | 'this'
subroutineCall:
    subroutineName '(' expressionList ')'
  | (className | varName) '.' subroutineName
    '(' expressionList ')'
expressionList: (expression (',' expression)*)?


--------------------------------------------------
-- A design for an improved tokenizer

- Tokenizer splits the entire file into tokens
  and stores them in a list
- Keeps track of a current token
- Provides functions
    - next() : advances the current index
      and returns the new current token
    - peek() : return the next token without
      advancing the current token index

-------------------------------------------
-- compiler pseudocode

compileClass():
  skip token 'class'
  read the className & save it somehwere
  skip '{'
  // (process classVarDecs)

  while (peek() != '}'):
    compileSubroutine()

  skip '}'

compileSubroutine():
  read subroutine type
  read return type, name, parameter list
  skip '{'
  while ( peek() == 'var'):
    readVarDec()

  locals = # of local variables (from symbol table)
  emit(f'function {className}.{functionName} {locals}')

  compileStatements()

  clear local symbol table

readVarDec():
  skip 'var'
  read in variables + their type, add to the
    local symbol table  (symbol table
    keeps track of the next available indices)
  skip ';'

compileStatements():
  while (peek() != '}'):   // ???
    compileStatement()

compileStatement():
  read token
  if (token == 'let'):
    compileLet()
  elif ...

compileLet():
  read varName
  // (optional [ expression ])
  skip '='
  compileExpression()
  look up var name in symbol table
  emit(f'pop {segment} {index}')

compileExpression():
  

--------------------------------------------------
-- Symbol table

What information do we need to know about
a variable?

- name (key)
- index
- kind (local, argument, static, field)
- type

Really two symbol tables:
- "global" one for static + field variables
- "local" one for local + argument variables,
  reset every time we compile a new function.
